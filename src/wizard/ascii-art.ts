import chalk from 'chalk';

/**
 * Ralph Wiggum ASCII art for terminal display
 */

// Full Ralph Wiggum ASCII art - detailed version for welcome screen
export const RALPH_FULL = chalk.yellow(`
                                    ˆ    5

                  ÀÀ   À  ŸÀv  Àv  ÀÀv
             À  FÀÀ  ÀÀÀ  ÀÀÀv  ÀÀ  ÀÀÀ
        w   ÀÀ   ÀÀv  ÀÀÀ  ÀÀêÀÀ  vÀÀ  vÀÀÀ  À
          Àv  vÀÀÀ  ÎÀÀ   ÀÀÀÀ  ÀÀêêÀÀ  ÀÀÀ   ÀÀÀ  vÀ
       X   ÀÀ  ÀÀÀÀÀ  ÀÀÀ   ÀÀÀÀ  ÀÀêêêRÀ  vÀÀÀ  vÀÀÀ   ÀÀ
         ÆÆ  ÀÀ   ÀÀÀÀv  ÀÀÀ   ÀÀêÀÀ  ÀÀÀÀÀÀÀÀ vÀÐÀÀ  vÀÀÀ~  ÀÀ
    ò   ÆÆ   ÀÀ  ÀÀ:  vÀÀÀÀŽÀÀÀÀÀêêÀÀÀÀÀŽvvüÀÀÀÀÀÀêêÀÀ  ÀÀÀÀ—  ÀÀ‚
      ÆÆÆÆ  ƒÀÀÀ–          ÀÀÀêêêêêÀÀÀ           ÀÀÀêŽÀÀ  ÀŽÀÀ  vÀÀv
          vÀÀÀ  ÆÆÆÆÆÆÆÆÆ  ÀÀêêêêÀÀv  ÆÆÆÆÆÆÆÆÆ  vÀÀêÀÀ  ÀÀêÀÀ  3ÀÀ\` ì
          ÀÀÀ  ÆÆÆÆÆÆÆÆÆÆÆ  ÀÀêêÐÀÀ  ÆÆÆÆÆÆÆÆÆÆÆ  µÀÀêÀ"  ÀêXÀÀ  ÀÀÀ  Æ
         ÀÀÀ  ÆÆÆÆÆ  ÆÆÆÆÆ  vÀêêÐÀ  ÆÆÆÆÆ   ÆÆÆÆÆ  ÀÀêÀÀ vÀêÐHÀ   ÀÀÀ  Æ
         ÀÀÀ  ÆÆÆÆÆ  ÆÆÆÆÆ  vÀêêÐÀ  ÆÆÆÆÆÆÆÆÆÆÆÆÆ  vÀêKÀÀÀÀêêÐÀÀvßÀgÀv ÆÆ
         ÀŽÀ  ÆÆÆÆÆÆÆÆÆÆÆÆ  ÀÀÀêêÀv  ÆÆÆÆÆÆÆÆÆÆÆÆ  ÀÀêêêêêêêêÐXÀÀÀÀêÀÀ  Æ
         ÀÀÀÀ   ÆÆÆÆÆÆ¥      ÀÀêêÀÀf   ÆÆÆÆÆÆÆÆ   ÀÀgêêêêêêêêêêêêêêêÀÀ  ÆÆ
         ÀÀÐÀÀ%         ÀÀÀÀ  ÀêêêÀÀÀÀ          ÀÀÀgêêêêêêêêêêêÀÀÀÀÀÀÀ  ÆÆ
          ÀÐêÀÀÀÀÀÀÀÀ  ÀÀÀÀÀÀÀÀêêêêÐÀÀÀÀÀÀÀÀÀÀÀÀÀKêêêêêêêêêêêŽÀÀ3
         vÀÐêêêêRÀÀÀÀ   ÀÀÀvÀÀêêêêêêêêêÐÀÀÀÀÀKêêÐÀÀÀÀÐêêêêêêêRÀ  •ÀÀÀÀÀ
        ÀÀÀêêêêêêêêêÀÀÀ     IÀêêêêêêêêêêêêêêêêêêXÀvvÀÀXêêêêêêRÀvÀÀÐ  vÀÀ
       ÀÀÀÐêÀÀÀÀÀÀÀRêêÀÀÀÀÀÀÀÀÀêêêêêêêêêêêêêÀÀÀÀÀÀv  ÀÀêêêêêêÐÀÀÀ†    ÀÀ
       vÀÀÀÀÀv   vÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀv        ÀêêêêêêêgÀÀÀÀÀÀÀÀ
          ÀÀÀÀÀÀ                                ÙÀÀÀ  ÖÀêêêêêêêgÀ vÀÀ*
                      ÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀ êÀÀÀÀêêêêêêêgÀ
                          ÀêêêÐXXÐÐXXÐêêêêêêêêêêêêêêêêêêêêêêêêêÀÀÀ
                       ÀêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêêKÀÀÀv
                       ÀêêêêêêêêêêêêêêêÀÀÀÀÀÀœÐêêêêêêêêÀÀÀÀÀÀ
                        ÀêêêêêêêêêêêêêÀÀÀÀKÀÀÀÀÀÀÀÀÀÀÀÀÀÀÀv    ³³³
                   ³³³³©  ÀêêêêêêêêêêÐœÀÀv                    ³³³³';³
                  ³³'³  h  ÀÐêêêêêêêêêÀÀÀ   ³³³³³³³³³³³³³³³³³³³¹‚˜˜‚³³³
                 ³³;˜ˆ³´    ÀÀêêêêêêÐÀÀÀ´  ³³³³³³'˜˜˜˜˜˜˜˜˜˜˜˜˜˜'–³³³
                  ³‚ˆˆˆ'³³   vÀÀKêêêÀÀÀv   ¤³³˜   ³³³­˜˜˜˜˜˜˜˜˜'³³³³
                 [³³³³³³³³I7   ÀÀÀÀÀÀG   Ì           ³³³˜˜'²³³³³¹
                             ³   1ÀÀ                  ³³³³³

`);

// Simpler welcome for smaller terminals
export const RALPH_WELCOME_SMALL = `
${chalk.yellow('   ╭─────────╮')}
${chalk.yellow('   │')} ${chalk.cyan('◉')}   ${chalk.cyan('◉')} ${chalk.yellow('│')}
${chalk.yellow('   │')}  ${chalk.yellow('‿‿‿')}  ${chalk.yellow('│')}
${chalk.yellow('   ╰')}${chalk.blue('─▄▄▄▄─')}${chalk.yellow('╯')}
`;

// Working Ralph small version
export const RALPH_WORKING_SMALL = `
${chalk.yellow('   ╭─────────╮')} ${chalk.yellow('o')}
${chalk.yellow('   │')} ${chalk.cyan('◉')}   ${chalk.cyan('◉')} ${chalk.yellow('│')}${chalk.yellow('/')}
${chalk.yellow('   │')}  ${chalk.yellow('‿‿‿')}  ${chalk.yellow('├─')}
${chalk.yellow('   ╰')}${chalk.blue('─▄▄▄▄─')}${chalk.yellow('╯')}
`;

// Error Ralph (sad)
export const RALPH_ERROR = `
${chalk.yellow('        ╭──────────────╮')}
${chalk.yellow('       ╱')}${chalk.yellow('  ┌─┐  ┌─┐')}${chalk.yellow('    ╲')}
${chalk.yellow('      │')}${chalk.red('   ◉')}${chalk.yellow('    ')}${chalk.red('◉')}${chalk.yellow('     │')}
${chalk.yellow('      │')}${chalk.yellow('     ╭─╮')}${chalk.yellow('      │')}
${chalk.yellow('      │')}${chalk.yellow('    ╰───╯')}${chalk.yellow('     │')}
${chalk.yellow('       ╲')}${chalk.blue('  ▄▄▄▄▄')}${chalk.yellow('    ╱')}
${chalk.blue('         ▀▀▀▀▀▀▀')}
`;

/**
 * Ralph quotes for fun
 */
export const RALPH_QUOTES = [
  "Hi, I'm helping!",
  "Me fail English? That's unpossible!",
  "I'm learnding!",
  "My cat's breath smells like cat food.",
  'I bent my wookiee.',
  "I'm a unitard!",
  'When I grow up, I want to be a principal or a caterpillar.',
  'I found a moon rock in my nose!',
];

export function getRandomRalphQuote(): string {
  return RALPH_QUOTES[Math.floor(Math.random() * RALPH_QUOTES.length)];
}

// Spinner frames (dots style like Claude CLI)
const SPINNER_FRAMES = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];

// Shimmer colors for the pulse effect
const SHIMMER_COLORS = [
  '#6B7280', // gray-500
  '#9CA3AF', // gray-400
  '#D1D5DB', // gray-300
  '#F3F4F6', // gray-100
  '#FFFFFF', // white (peak)
  '#F3F4F6', // gray-100
  '#D1D5DB', // gray-300
  '#9CA3AF', // gray-400
  '#6B7280', // gray-500
];

/**
 * Modern loading display with shimmer text animation
 * Similar to Claude CLI / Cursor style
 * Uses single-line updates with carriage return for better terminal compatibility
 */
export class RalphAnimator {
  private frame = 0;
  private interval: NodeJS.Timeout | null = null;
  private startTime = Date.now();
  private currentMessage = '';
  private outputLines: string[] = [];
  private maxOutputLines = 3;
  private shimmerOffset = 0;

  /**
   * Start the loading animation
   */
  start(message: string = 'Thinking...'): void {
    this.currentMessage = message;
    this.startTime = Date.now();
    this.frame = 0;
    this.shimmerOffset = 0;
    this.outputLines = [];

    // Hide cursor
    process.stdout.write('\x1B[?25l');

    // Initial render
    this.render();

    // Main animation loop
    this.interval = setInterval(() => {
      this.frame++;
      // Shimmer moves across text (cycle through message length + some buffer)
      const textLen = this.currentMessage.length + 10;
      this.shimmerOffset = (this.shimmerOffset + 1) % textLen;
      this.render();
    }, 80);
  }

  /**
   * Stop the animation
   */
  stop(finalMessage?: string): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }

    // Clear the current line
    process.stdout.write('\r\x1B[K');

    // Show cursor
    process.stdout.write('\x1B[?25h');

    if (finalMessage) {
      console.log(finalMessage);
    }
  }

  /**
   * Add output line (from streaming) - silently collected, not displayed
   */
  addOutput(line: string): void {
    const cleaned = line.trim();
    if (cleaned && cleaned.length > 5) {
      this.outputLines.push(cleaned);
      if (this.outputLines.length > this.maxOutputLines) {
        this.outputLines.shift();
      }
    }
  }

  /**
   * Update the current message
   */
  updateMessage(message: string): void {
    this.currentMessage = message;
  }

  /**
   * Render single-line status with carriage return (more compatible)
   */
  private render(): void {
    const spinner = SPINNER_FRAMES[this.frame % SPINNER_FRAMES.length];
    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
    const timeStr = elapsed > 0 ? ` ${elapsed}s` : '';

    // Apply shimmer effect to message
    const shimmerText = this.applyShimmer(this.currentMessage);

    // Build single line output
    const line = `  ${chalk.cyan(spinner)} ${shimmerText}${chalk.dim(timeStr)}`;

    // Clear line and write new content using carriage return
    // \r moves cursor to start of line, \x1B[K clears to end of line
    process.stdout.write(`\r\x1B[K${line}`);
  }

  /**
   * Apply shimmer/pulse effect - a bright spot moves across the text
   */
  private applyShimmer(text: string): string {
    const chars = [...text];
    const shimmerWidth = 5; // Width of the bright spot
    const shimmerCenter = this.shimmerOffset;

    let result = '';
    for (let i = 0; i < chars.length; i++) {
      const distance = Math.abs(i - shimmerCenter);

      if (distance < shimmerWidth) {
        // Near the shimmer - use brighter color
        const intensity = 1 - distance / shimmerWidth;
        const colorIndex = Math.floor(intensity * (SHIMMER_COLORS.length - 1));
        result += chalk.hex(SHIMMER_COLORS[colorIndex])(chars[i]);
      } else {
        // Base color - dim
        result += chalk.gray(chars[i]);
      }
    }
    return result;
  }
}
