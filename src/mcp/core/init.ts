import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join, basename } from 'path';
import YAML from 'yaml';
import { detectBestAgent } from '../../loop/agents.js';

export interface InitCoreOptions {
  path: string;
  name?: string;
}

export interface InitCoreResult {
  success: boolean;
  path: string;
  filesCreated: string[];
  error?: string;
}

type ProjectType = 'nodejs' | 'python' | 'rust' | 'go' | 'unknown';

interface ProjectInfo {
  type: ProjectType;
  name: string;
  testCmd?: string;
  buildCmd?: string;
  lintCmd?: string;
}

function detectProject(cwd: string): ProjectInfo {
  // Node.js
  if (existsSync(join(cwd, 'package.json'))) {
    try {
      const pkg = JSON.parse(readFileSync(join(cwd, 'package.json'), 'utf-8'));
      const scripts = pkg.scripts || {};
      return {
        type: 'nodejs',
        name: pkg.name || basename(cwd),
        testCmd: scripts.test ? 'npm test' : undefined,
        buildCmd: scripts.build ? 'npm run build' : undefined,
        lintCmd: scripts.lint ? 'npm run lint' : undefined,
      };
    } catch {
      return { type: 'nodejs', name: basename(cwd) };
    }
  }

  // Python
  if (existsSync(join(cwd, 'pyproject.toml')) || existsSync(join(cwd, 'setup.py'))) {
    return {
      type: 'python',
      name: basename(cwd),
      testCmd: 'pytest',
      lintCmd: 'ruff check .',
    };
  }

  // Rust
  if (existsSync(join(cwd, 'Cargo.toml'))) {
    return {
      type: 'rust',
      name: basename(cwd),
      testCmd: 'cargo test',
      buildCmd: 'cargo build',
      lintCmd: 'cargo clippy',
    };
  }

  // Go
  if (existsSync(join(cwd, 'go.mod'))) {
    return {
      type: 'go',
      name: basename(cwd),
      testCmd: 'go test ./...',
      buildCmd: 'go build ./...',
      lintCmd: 'golangci-lint run',
    };
  }

  return { type: 'unknown', name: basename(cwd) };
}

function generateAgentsMd(project: ProjectInfo): string {
  const validationCmds = [
    project.testCmd,
    project.buildCmd,
    project.lintCmd,
  ].filter(Boolean);

  return `# AGENTS.md

This file defines how Ralph operates in this project.

## Validation Commands

Run these after each task to ensure quality:

\`\`\`bash
${validationCmds.length > 0 ? validationCmds.join('\n') : '# Add your test/build/lint commands here'}
\`\`\`

## Build Instructions

${project.type === 'nodejs' ? '1. Run `npm install` to install dependencies\n2. Run `npm run build` to build (if applicable)\n3. Run `npm test` to verify' : ''}
${project.type === 'python' ? '1. Create virtual environment: `python -m venv venv`\n2. Install dependencies: `pip install -e .`\n3. Run tests: `pytest`' : ''}
${project.type === 'rust' ? '1. Run `cargo build` to compile\n2. Run `cargo test` to verify' : ''}
${project.type === 'go' ? '1. Run `go mod tidy` to sync dependencies\n2. Run `go build ./...` to compile\n3. Run `go test ./...` to verify' : ''}
${project.type === 'unknown' ? '1. Add your build instructions here' : ''}

## Code Patterns

- Follow existing code style
- Add tests for new functionality
- Keep functions small and focused
- Use meaningful names

## Task Completion

A task is complete when:
1. All validation commands pass
2. Code is committed (if auto-commit enabled)
3. No TODO comments left unaddressed
`;
}

function generatePromptBuild(): string {
  return `# Building Mode

You are in BUILDING mode. Execute tasks from the implementation plan.

## Process

1. Read IMPLEMENTATION_PLAN.md for the current task
2. Implement the task following patterns in AGENTS.md
3. Run validation commands after each change
4. If tests fail, fix the issues before moving on
5. Mark the task as complete in IMPLEMENTATION_PLAN.md
6. Move to the next task

## Rules

- One task at a time
- Validate after each change
- Commit working code only
- Update the plan as you learn

## Completion Signal

When all tasks are done, output: <TASK_DONE>
If blocked, output: <TASK_BLOCKED> with explanation
`;
}

function generatePromptPlan(): string {
  return `# Planning Mode

You are in PLANNING mode. Analyze specs and create an implementation plan.

## Process

1. Read all files in specs/ folder
2. Analyze existing codebase
3. Identify gaps between specs and implementation
4. Create prioritized task list in IMPLEMENTATION_PLAN.md

## Task Format

Each task in IMPLEMENTATION_PLAN.md should have:
- [ ] Clear, actionable description
- Acceptance criteria
- Dependencies (if any)

## Rules

- Do NOT implement anything
- Only analyze and plan
- Keep tasks small (< 30 min each)
- Order by dependencies

## Output

Update IMPLEMENTATION_PLAN.md with the task list.
`;
}

function generateImplementationPlan(): string {
  return `# Implementation Plan

> Auto-generated by Ralph. Update as tasks complete.

## Status

- [ ] Task 1: (describe first task)
- [ ] Task 2: (describe second task)

## Notes

Add discoveries and learnings here as you work.
`;
}

function generateExampleSpec(projectName: string): string {
  return `# ${projectName} Specification

## Overview

Describe what this project does.

## Features

### Feature 1: (name)

Description of the feature.

**Acceptance Criteria:**
- [ ] Criterion 1
- [ ] Criterion 2

### Feature 2: (name)

Description of the feature.

## Technical Requirements

- List technical constraints
- Performance requirements
- Security considerations
`;
}

/**
 * Core initialization logic without CLI dependencies
 */
export async function initCore(options: InitCoreOptions): Promise<InitCoreResult> {
  const cwd = options.path;
  const filesCreated: string[] = [];

  try {
    // Check if directory exists
    if (!existsSync(cwd)) {
      mkdirSync(cwd, { recursive: true });
    }

    // Check if already initialized
    if (existsSync(join(cwd, 'AGENTS.md'))) {
      return {
        success: false,
        path: cwd,
        filesCreated: [],
        error: 'Ralph Playbook files already exist',
      };
    }

    // Detect project
    const project = detectProject(cwd);
    if (options.name) {
      project.name = options.name;
    }

    // Detect agent
    const agent = await detectBestAgent();
    const agentType = agent?.type || 'claude-code';

    // Create AGENTS.md
    writeFileSync(join(cwd, 'AGENTS.md'), generateAgentsMd(project));
    filesCreated.push('AGENTS.md');

    // Create PROMPT files
    writeFileSync(join(cwd, 'PROMPT_build.md'), generatePromptBuild());
    filesCreated.push('PROMPT_build.md');

    writeFileSync(join(cwd, 'PROMPT_plan.md'), generatePromptPlan());
    filesCreated.push('PROMPT_plan.md');

    // Create implementation plan
    writeFileSync(join(cwd, 'IMPLEMENTATION_PLAN.md'), generateImplementationPlan());
    filesCreated.push('IMPLEMENTATION_PLAN.md');

    // Create specs folder with example
    const specsDir = join(cwd, 'specs');
    if (!existsSync(specsDir)) {
      mkdirSync(specsDir, { recursive: true });
      writeFileSync(
        join(specsDir, 'example.md'),
        generateExampleSpec(project.name)
      );
      filesCreated.push('specs/example.md');
    }

    // Create .ralph config
    const ralphDir = join(cwd, '.ralph');
    if (!existsSync(ralphDir)) {
      mkdirSync(ralphDir, { recursive: true });
      const config = {
        agent: agentType,
        auto_commit: true,
        max_iterations: 50,
        validation: {
          test: project.testCmd || null,
          build: project.buildCmd || null,
          lint: project.lintCmd || null,
        },
      };
      writeFileSync(join(ralphDir, 'config.yaml'), YAML.stringify(config));
      filesCreated.push('.ralph/config.yaml');
    }

    return {
      success: true,
      path: cwd,
      filesCreated,
    };
  } catch (error) {
    return {
      success: false,
      path: cwd,
      filesCreated,
      error: (error as Error).message,
    };
  }
}
